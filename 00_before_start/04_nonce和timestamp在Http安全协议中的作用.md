
***参考***
> [参考](https://www.cnblogs.com/bestzrz/archive/2011/09/03/2164620.html "Markdown")
>
### nonce和timestamp在Http安全协议中的作用


前段时间给客户网站做新浪微博账号登录功能，对OAuth协议以及相关的一些安全协议做了一些研究，顺便就记录一下学习心得吧。在这里就不打算具体讲OAuth的协议流程了，而是针对OAuth请求头里的nonce（随机数）、timestamp（时间戳）、signatrue（签名）这些参数的作用做一下总结。

 

首先看一下HTTP规范里定义的Basic认证。

#### Basic认证及其安全问题

Basic认证是一个流程比较简单的协议，整个过程可以分为以下三个步骤：

a） 客户端使用GET方法向服务器请求资源。

b） 服务器返回401响应码和WWW-Authentication：Basic realm=”Family”响应头要求客户端进行身份验证。其中realm声明了资源所在的域。

c） 浏览器接收到以上HTTP响应头后，弹出登录框要求用户输入用户名和密码；用户提交的用户名和密码通过冒号串联起来并对其进行BASE64编码后再提交到服务器；服务器对提交上来的BASE64字符串进行验证，如果验证通过则返回200响应码。

 
 

 

 

Basic认证虽然简单、方便，但它只能作为对非敏感资源的访问认证，因为它并不安全，主要表现在以下几个方面：

1、 客户端提交的用户名和密码只经过简单的编码，攻击者只要窃听到该数据包，便可很容易的将其反编码为原始用户名和密码。

2、 即使客户端使用了一种比BASE64更复杂的编码方式使得攻击者无法对其反编码，攻击者也可以使用fiddler等工具将拦截到的HTTP报文重新提交给服务器，服务器只对编码的字符串进行验证，所以验证同样能通过。这种攻击方法称之为重放攻击（Replay-Attack）。

以上两个问题也是各种身份认证协议需要考虑到的安全问题，包括OAuth、Digest认证、NTLM认证等等认证机制都使用了nonce和timestamp来解决这些问题。

#### Nonce、Timestamp——解决Replay-Attack问题

Nonce是由服务器生成的一个随机数，在客户端第一次请求页面时将其发回客户端；客户端拿到这个Nonce，将其与用户密码串联在一起并进行非可逆加密（MD5、SHA1等等），然后将这个加密后的字符串和用户名、Nonce、加密算法名称一起发回服务器；服务器使用接收到的用户名到数据库搜索密码，然后跟客户端使用同样的算法对其进行加密，接着将其与客户端提交上来的加密字符串进行比较，如果两个字符串一致就表示用户身份有效。这样就解决了用户密码明文被窃取的问题，攻击者就算知道了算法名和nonce也无法解密出密码。

 

每个nonce只能供一个用户使用一次，这样就可以防止攻击者使用重放攻击，因为该Http报文已经无效。可选的实现方式是把每一次请求的Nonce保存到数据库，客户端再一次提交请求时将请求头中得Nonce与数据库中得数据作比较，如果已存在该Nonce，则证明该请求有可能是恶意的。然而这种解决方案也有个问题，很有可能在两次正常的资源请求中，产生的随机数是一样的，这样就造成正常的请求也被当成了攻击，随着数据库中保存的随机数不断增多，这个问题就会变得很明显。所以，还需要加上另外一个参数Timestamp（时间戳）。

 

Timestamp是根据服务器当前时间生成的一个字符串，与nonce放在一起，可以表示服务器在某个时间点生成的随机数。这样就算生成的随机数相同，但因为它们生成的时间点不一样，所以也算有效的随机数。

 

问题又来了，随着用户访问的增加，数据库中保存的nonce/timestamp/username数据量会变得非常大。对于这个问题，可选的解决方案是对数据设定一个“过期时间”，比如说在数据库中保存超过一天的数据将会被清除。如果是这样的，攻击者可以等待一天后，再将拦截到的HTTP报文提交到服务器，这时候因为nonce/timestamp/username数据已被服务器清除，请求将会被认为是有效的。要解决这个问题，就需要给时间戳设置一个超时时间，比如说将时间戳与服务器当前时间比较，如果相差一天则认为该时间戳是无效的。

HTTP消息体的加密

很不幸的是，经过上面这些复杂的处理后，我们的数据传输仍然是不安全的。我们都知道，http报文是以明文的方式在网络中传输的，包括Basic认证、Digest认证、OAuth、NTLM的这一系列认证机制都只是对HTTP头的信息作保护，而对于Http消息体的数据却没有作加密。以新浪首页的登录为例，它的账号就是以明文的方式传送的
 这样的方式是很不安全的，用户名和密码完全以明文的方式提交了。同样是新浪的网站——新浪微博就在登录前作了加密过的
加密的方法可以参考前面讲到的nonce+timestamp的方案。不过这只解决了登录的问题，在注册时就不能提交使用nonce和timestamp非可逆加密了，这个时候要使用非对称加密。在用户打开注册页时，服务器生成一个公钥/私钥对并将公钥返回给客户端，客户端使用该公钥将密码加密后提交到服务器，服务器使用私钥解密后再保存到数据库。非对称加密算法的特点是每一个公钥和私钥都是一一对应的，使用公钥加密后只有拥有私钥的人才能进行解密，所以攻击者截取到http报文也毫无用处。
当然，在条件允许的情况下，可以使用SSL来实现HTTP报文的加密，这种方案是在应用层和传输层中间添加一个SSL层，该层使用对称加密的方法将HTTP报文加密后再传递到传输层。

```shell script
小争哥第13课接口鉴权的课后评论：
使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进。
拿到这个需求，假设我们不了解接口鉴权，需求又不明确，我会我自己如下问题：
1.什么叫接口鉴权？搞清基本概念
2.接口鉴权最佳实践是什么？技术调研
3.appid和secret key从哪里来？用户自己申请还是我们授权？用户申请是以什么方式申请（网页还是邮件？申请的网页有人做了么？）追问下去。
4.appid secretkey存储在什么地方呢？数据存储
5.用户如何使用？需要为用户提供接口鉴权使用手册和文档，及示例代码。写用户手册，文档。
6.这个功能如何测试？提前想好如何测试
7.接口鉴权功能何时上线？估计工期
8.鉴权成功或失败返回码和信息定义？约定返回结果

关于防止重放攻击：请求参数中还可以加入nonce（随机正整数），两次请求的nonce不能重复，timestamp和nonce结合进一步防止重放攻击
```
