###单例模式 ###

---
#### 概念
>观察者模式(**Observer Design Pattern**):
---
#### 要解决的问题/用途
- 资源访问冲突
- 表示全局唯一类,如*配置信息类*、*连接池类*、*ID生成器类*等
---
#### 如何实现
|  实现方式   | 概念  | 是否线程安全  | 是否支持延迟加载  |  适用场景|
|  ----  | ----  |----|----|----|
| 饿汉式  | 单例实例在类加载的时候<br>instance静态实例就已经创建并初始化好了 | 是 | 否 | 详见代码  |
| 懒汉式  | 单例实例在第一次被使用时构建 | 可以加锁实现线程安全 | 是  |详见代码|
| 双重检测  | 只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。<br>所以，这种实现方式解决了懒汉式并发度低的问题 | 是|是  |详见代码|
| 静态内部类  | java特有,在此不做讲解 |- | - |-|
| 枚举  |  java特有,在此不做讲解 |- | - |-|

#### 缺点
- 单例对**OOP**特性的支持不友好  
  封装方面,**GetInstance**的使用方式违背了基于接口而非实现的设计原则;
- 单例会隐藏类之间的依赖关系
  单例对象在使用的时候,直接调用**GetInstance**就可以了,显示创建、不需要依赖参数传递.在阅读代码的时候,我们就需要仔细查看每个函数的代码实现,才能知道这个类到底依赖了哪些单例类
- 单例对代码的扩展性不友好
  数据库连接池类设计成了单例类,如果需要多个连接池实例(比如慢sql一个,其他sql一个),显然单例模式无法实现
- 单例对代码的可测试性不友好
  如果单例类依赖比较重的外部资源,比如DB,我们在写单元测试的时候,无法通过**GetInstance**传入**mockDB**的方式将它替换掉


